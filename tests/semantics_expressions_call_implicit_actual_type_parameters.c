#include "runner.h"

static void actual_type_parameters_make_signature_match_monomorphic_function(void)
{
    format_test_name("semantics/expressions/call/implicit_actual_type_parameters/actual_type_parameters_make_signature_match_monomorphic_function");

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "function a(I32 b) : I32\n"
                          "    return b\n"
                          "end\n"
                          "\n"
                          "function a[T](T b) : T\n"
                          "    return b\n"
                          "end\n"
                          "\n"
                          "function c(I32 d) : I32\n"
                          "    return a(d)\n"
                          "end");

    SET_COMMAND_LINE("semantics/expressions/call/implicit_actual_type_parameters/actual_type_parameters_make_signature_match_monomorphic_function.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: %s" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    function" NEW_LINE
                       "        name: a" NEW_LINE
                       "        formal_parameter" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: b" NEW_LINE
                       "        return_type: I32" NEW_LINE
                       "        return_statement" NEW_LINE
                       "            reference_expression" NEW_LINE
                       "                type: I32" NEW_LINE
                       "                name: b" NEW_LINE
                       "    function" NEW_LINE
                       "        name: a" NEW_LINE
                       "        formal_type_parameter: T" NEW_LINE
                       "        formal_parameter" NEW_LINE
                       "            type_reference: T" NEW_LINE
                       "            name: b" NEW_LINE
                       "        return_type_reference: T" NEW_LINE
                       "        return_statement" NEW_LINE
                       "            reference_expression" NEW_LINE
                       "                name: b" NEW_LINE
                       "    function" NEW_LINE
                       "        name: c" NEW_LINE
                       "        formal_parameter" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: d" NEW_LINE
                       "        return_type: I32" NEW_LINE
                       "        return_statement" NEW_LINE
                       "            call_expression" NEW_LINE
                       "                type: I32" NEW_LINE
                       "                reference_expression" NEW_LINE
                       "                    type: Function(I32) : I32" NEW_LINE
                       "                    name: a" NEW_LINE
                       "                reference_expression" NEW_LINE
                       "                    type: I32" NEW_LINE
                       "                    name: d" NEW_LINE,
                       test.source_paths[0]);
}

static void call_reference_that_is_not_a_function(void)
{
    format_test_name("semantics/expressions/call/implicit_actual_type_parameters/call_reference_that_is_not_a_function");

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "function a(I32 b, I32 c)\n"
                          "    b(c)\n"
                          "end");

    SET_COMMAND_LINE("semantics/expressions/call/implicit_actual_type_parameters/call_reference_that_is_not_a_function.owen");

    format_expectation(&test.expected_error, 
                       "%s:5:5: Function type expected but found I32." NEW_LINE,
                       test.source_paths[0]);
}

static void error_nested_in_a_polymorphic_function_call(void)
{
    format_test_name("semantics/expressions/call/implicit_actual_type_parameters/error_nested_in_a_polymorphic_function_call");

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "enumeration Direction : U8\n"
                          "    up\n"
                          "    right\n"
                          "    down\n"
                          "    left\n"
                          "end\n"
                          "\n"
                          "function do_stuff() : Direction\n"   
                          "    return do_stuff(Direction.up, Direction.down)\n"
                          "end\n"
                          "\n"
                          "function do_stuff[T](T a, T b) : T\n"
                          "    return a + b\n"
                          "end");

    SET_COMMAND_LINE("semantics/expressions/call/implicit_actual_type_parameters/error_nested_in_a_polymorphic_function_call.owen");

    format_expectation(&test.expected_error, 
                       "semantics/expressions/call/implicit_actual_type_parameters/error_nested_in_a_polymorphic_function_call.owen:16:14: Operator not defined for Direction and Direction." NEW_LINE
                       "Polymorphic stack:" NEW_LINE
                       "    semantics/expressions/call/implicit_actual_type_parameters/error_nested_in_a_polymorphic_function_call.owen:12:20: do_stuff[Direction](Direction a, Direction b) : Direction" NEW_LINE);
}

static void error_nested_in_multiple_polymorphic_function_calls(void)
{
    format_test_name("semantics/expressions/call/implicit_actual_type_parameters/error_nested_in_multiple_polymorphic_function_calls");

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "enumeration Direction : U8\n"
                          "    up\n"
                          "    right\n"
                          "    down\n"
                          "    left\n"
                          "end\n"
                          "\n"
                          "function do_stuff() : Direction\n"
                          "    return do_stuff(Direction.up)\n"
                          "end\n"
                          "\n"
                          "function do_stuff[T](T a) : T\n"
                          "    return do_stuff(a, a)\n"
                          "end\n"
                          "\n"
                          "function do_stuff[T](T a, T b) : T\n"
                          "    return a + b\n"
                          "end");

    SET_COMMAND_LINE("semantics/expressions/call/implicit_actual_type_parameters/error_nested_in_multiple_polymorphic_function_calls.owen");

    format_expectation(&test.expected_error, 
                       "semantics/expressions/call/implicit_actual_type_parameters/error_nested_in_multiple_polymorphic_function_calls.owen:20:14: Operator not defined for Direction and Direction." NEW_LINE
                       "Polymorphic stack:" NEW_LINE
                       "    semantics/expressions/call/implicit_actual_type_parameters/error_nested_in_multiple_polymorphic_function_calls.owen:12:20: do_stuff[Direction](Direction a) : Direction" NEW_LINE
                       "    semantics/expressions/call/implicit_actual_type_parameters/error_nested_in_multiple_polymorphic_function_calls.owen:16:20: do_stuff[Direction](Direction a, Direction b) : Direction" NEW_LINE);
}

static void formal_type_parameter_nested_in_compound(void)
{
    format_test_name("semantics/expressions/call/implicit_actual_type_parameters/formal_type_parameter_nested_in_compound");

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T]\n"
                          "    T t\n"
                          "end\n"
                          "\n"
                          "function a[T](A[T] b) : T\n"
                          "    return b.t\n"
                          "end\n"
                          "\n"
                          "function c(A[I32] d) : I32\n"
                          "    return a(d)\n"
                          "end");

    SET_COMMAND_LINE("semantics/expressions/call/implicit_actual_type_parameters/formal_type_parameter_nested_in_compound.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/expressions/call/implicit_actual_type_parameters/formal_type_parameter_nested_in_compound.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        formal_type_parameter: T" NEW_LINE
                       "        field" NEW_LINE
                       "            type_reference: T" NEW_LINE
                       "            name: t" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        actual_type_parameter: I32" NEW_LINE
                       "        field" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: t" NEW_LINE
                       "    function" NEW_LINE
                       "        name: a" NEW_LINE
                       "        formal_type_parameter: T" NEW_LINE
                       "        formal_parameter" NEW_LINE
                       "            type_reference: A[T]" NEW_LINE
                       "            name: b" NEW_LINE
                       "        return_type_reference: T" NEW_LINE
                       "        return_statement" NEW_LINE
                       "            field_access" NEW_LINE
                       "                reference_expression" NEW_LINE
                       "                    name: b" NEW_LINE
                       "                field: t" NEW_LINE
                       "    function" NEW_LINE
                       "        name: a" NEW_LINE
                       "        actual_type_parameter: I32" NEW_LINE
                       "        formal_parameter" NEW_LINE
                       "            type: A[I32]" NEW_LINE
                       "            name: b" NEW_LINE
                       "        return_type: I32" NEW_LINE
                       "        return_statement" NEW_LINE
                       "            field_access" NEW_LINE
                       "                type: I32" NEW_LINE
                       "                reference_expression" NEW_LINE
                       "                    type: A[I32]" NEW_LINE
                       "                    name: b" NEW_LINE
                       "                field: t" NEW_LINE
                       "    function" NEW_LINE
                       "        name: c" NEW_LINE
                       "        formal_parameter" NEW_LINE
                       "            type: A[I32]" NEW_LINE
                       "            name: d" NEW_LINE
                       "        return_type: I32" NEW_LINE
                       "        return_statement" NEW_LINE
                       "            call_expression" NEW_LINE
                       "                type: I32" NEW_LINE
                       "                reference_expression" NEW_LINE
                       "                    type: Function(A[I32]) : I32" NEW_LINE
                       "                    name: a" NEW_LINE
                       "                reference_expression" NEW_LINE
                       "                    type: A[I32]" NEW_LINE
                       "                    name: d" NEW_LINE);
}

static void formal_type_parameter_not_specified_by_actual_parameters(void)
{
    format_test_name("semantics/expressions/call/implicit_actual_type_parameters/formal_type_parameter_not_specified_by_actual_parameters");

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "function a[T1, T2](T1 b) : T2\n"
                          "    return b + 2\n"
                          "end\n"
                          "\n"
                          "function c(I32 d) : I32\n"
                          "    return a(d)\n"
                          "end");

    SET_COMMAND_LINE("semantics/expressions/call/implicit_actual_type_parameters/formal_type_parameter_not_specified_by_actual_parameters.owen");

    format_expectation(&test.expected_error, 
                       "%s:9:13: T2 could not be inferred from the call site. Specify it explicitly." NEW_LINE,
                       test.source_paths[0]);
}

static void formal_type_parameter_redefined_by_actual_parameter(void)
{
    format_test_name("semantics/expressions/call/implicit_actual_type_parameters/formal_type_parameter_redefined_by_actual_parameter");

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "function a[T](T b, T c) : T\n"
                          "    return b + c\n"
                          "end\n"
                          "\n"
                          "function d(I32 e, F32 f) : I32\n"
                          "    return a(e, f)\n"
                          "end");

    SET_COMMAND_LINE("semantics/expressions/call/implicit_actual_type_parameters/formal_type_parameter_redefined_by_actual_parameter.owen");

    format_expectation(&test.expected_error, 
                       "%s:9:17: T redefined as F32. It was originally I32." NEW_LINE,
                       test.source_paths[0]);
}

static void formal_type_parameters_is_actual_type_parameter(void)
{
    format_test_name("semantics/expressions/call/implicit_actual_type_parameters/formal_type_parameters_is_actual_type_parameter");

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "function a[T](T b) : T\n"
                          "    return b\n"
                          "end\n"
                          "\n"
                          "function c(I32 d) : I32\n"
                          "    return a(d)\n"
                          "end");

    SET_COMMAND_LINE("semantics/expressions/call/implicit_actual_type_parameters/formal_type_parameters_is_actual_type_parameter.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/expressions/call/implicit_actual_type_parameters/formal_type_parameters_is_actual_type_parameter.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    function" NEW_LINE
                       "        name: a" NEW_LINE
                       "        formal_type_parameter: T" NEW_LINE
                       "        formal_parameter" NEW_LINE
                       "            type_reference: T" NEW_LINE
                       "            name: b" NEW_LINE
                       "        return_type_reference: T" NEW_LINE
                       "        return_statement" NEW_LINE
                       "            reference_expression" NEW_LINE
                       "                name: b" NEW_LINE
                       "    function" NEW_LINE
                       "        name: a" NEW_LINE
                       "        actual_type_parameter: I32" NEW_LINE
                       "        formal_parameter" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: b" NEW_LINE
                       "        return_type: I32" NEW_LINE
                       "        return_statement" NEW_LINE
                       "            reference_expression" NEW_LINE
                       "                type: I32" NEW_LINE
                       "                name: b" NEW_LINE
                       "    function" NEW_LINE
                       "        name: c" NEW_LINE
                       "        formal_parameter" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: d" NEW_LINE
                       "        return_type: I32" NEW_LINE
                       "        return_statement" NEW_LINE
                       "            call_expression" NEW_LINE
                       "                type: I32" NEW_LINE
                       "                reference_expression" NEW_LINE
                       "                    type: Function(I32) : I32" NEW_LINE
                       "                    name: a" NEW_LINE
                       "                reference_expression" NEW_LINE
                       "                    type: I32" NEW_LINE
                       "                    name: d" NEW_LINE);
}

static bool literal_as_actual_parameter(void)
{
    static uint8_t index = 0;
    while (index < TYPES_LENGTH && !types[index].default_value_name)
        index++;

    if (index == TYPES_LENGTH)
        return false;

    format_test_name("semantics/expressions/call/implicit_actual_type_parameters/%s_literal_where_%s_typed_actual_parameter_expected", types[index].file_friendly_default_value_name, types[index].file_friendly_name);

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "function a[T](T b) : T\n"
                          "    return b\n"
                          "end\n"
                          "\n"
                          "function c()\n"
                          "    a(%s)\n"
                          "end", 
                          types[index].default_value);

    format_command_line_options("%s", test.source_paths[0]);
    format_expectation(&test.expected_error, 
                       "%s:9:7: %s type cannot be inferred." NEW_LINE,
                       test.source_paths[0],
                       types[index].default_value_name);

    index++;
    return true;
}

static void retain_address_of_unretainable_expression(void)
{
    format_test_name("semantics/expressions/call/implicit_actual_type_parameters/retain_address_of_unretainable_expression");

    format_source_path(0, "semantics/expressions/call/implicit_actual_type_parameters/retain_address_of_unretainable_expression.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "function a[T](#`T b)\n"
                          "    T c = 0\n"
                          "    b = #c\n"
                          "end\n"
                          "\n"
                          "function d(#`I32 e)\n"
                          "    a(e)\n"
                          "end");

    SET_COMMAND_LINE("semantics/expressions/call/implicit_actual_type_parameters/retain_address_of_unretainable_expression.owen");
    format_expectation(&test.expected_error, 
                       "%s:6:10: Parameters and variables cannot be retained." NEW_LINE
                       "Polymorphic stack:" NEW_LINE
                       "    %s:10:6: a[I32](#`I32 b)" NEW_LINE,
                       test.source_paths[0],
                       test.source_paths[0]);
}

bool semantics_expressions_call_implicit_actual_type_parameters(void)
{
    static uint8_t state;
    switch (state)
    {
        case 0:
            actual_type_parameters_make_signature_match_monomorphic_function();
            state++;
            break;

        case 1:
            call_reference_that_is_not_a_function();
            state++;
            break;

        case 2:
            error_nested_in_a_polymorphic_function_call();
            state++;
            break;

        case 3:
            error_nested_in_multiple_polymorphic_function_calls();
            state++;
            break;

        case 4:
            formal_type_parameter_nested_in_compound();
            state++;
            break;

        case 5:
            formal_type_parameter_not_specified_by_actual_parameters();
            state++;
            break;

        case 6:
            formal_type_parameter_redefined_by_actual_parameter();
            state++;
            break;

        case 7:
            formal_type_parameters_is_actual_type_parameter();
            state++;
            break;

        case 8:
            if (literal_as_actual_parameter())
                break;

            state++;

        case 9:
            retain_address_of_unretainable_expression();
            state++;
            break;

        default:
            return false;
    }

    return true;
}
