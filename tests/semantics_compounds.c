#include "runner.h"

static void comparing_polymorphic_compound_with_non_matching_actual_type_parameters(void)
{
    format_test_name("semantics/compounds/comparing_polymorphic_compound_with_non_matching_actual_type_parameters");

    format_source_path(0, "semantics/compounds/comparing_polymorphic_compound_with_non_matching_actual_type_parameters.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T]\n"
                          "    T a\n"
                          "end\n"
                          "\n"
                          "function do_stuff(A[F64] a) : A[Bool]\n"
                          "    return a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/comparing_polymorphic_compound_with_non_matching_actual_type_parameters.owen");
    format_expectation(&test.expected_error, "semantics/compounds/comparing_polymorphic_compound_with_non_matching_actual_type_parameters.owen:9:12: A[Bool] expected but found A[F64]." NEW_LINE);
}

static void directly_recursive_monomorphic_compound_through_fixed_sized_array(void)
{
    format_test_name("semantics/compounds/directly_recursive_monomorphic_compound_through_fixed_sized_array");

    format_source_path(0, "semantics/compounds/directly_recursive_monomorphic_compound_through_fixed_sized_array.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A\n"
                          "    [3]A a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/directly_recursive_monomorphic_compound_through_fixed_sized_array.owen");
    format_expectation(&test.expected_error, "semantics/compounds/directly_recursive_monomorphic_compound_through_fixed_sized_array.owen:5:5: A is recursive." NEW_LINE);
}

static void directly_recursive_monomorphic_compound_through_itself(void)
{
    format_test_name("semantics/compounds/directly_recursive_monomorphic_compound_through_itself");

    format_source_path(0, "semantics/compounds/directly_recursive_monomorphic_compound_through_itself.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A\n"
                          "    A a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/directly_recursive_monomorphic_compound_through_itself.owen");
    format_expectation(&test.expected_error, "semantics/compounds/directly_recursive_monomorphic_compound_through_itself.owen:5:5: A is recursive." NEW_LINE);
}

static void directly_recursive_polymorphic_compound_through_fixed_sized_array(void)
{
    format_test_name("semantics/compounds/directly_recursive_polymorphic_compound_through_fixed_sized_array");

    format_source_path(0, "semantics/compounds/directly_recursive_polymorphic_compound_through_fixed_sized_array.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T]\n"
                          "    [3]A[T] a\n"
                          "end\n"
                          "\n"
                          "structure B\n"
                          "    A[I32] a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/directly_recursive_polymorphic_compound_through_fixed_sized_array.owen");
    format_expectation(&test.expected_error, 
                       "semantics/compounds/directly_recursive_polymorphic_compound_through_fixed_sized_array.owen:5:5: A[I32] is recursive." NEW_LINE
                       "Polymorphic stack:" NEW_LINE
                       "    semantics/compounds/directly_recursive_polymorphic_compound_through_fixed_sized_array.owen:9:5: A[I32]" NEW_LINE);
}

static void directly_recursive_polymorphic_compound_through_itself(void)
{
    format_test_name("semantics/compounds/directly_recursive_polymorphic_compound_through_itself");

    format_source_path(0, "semantics/compounds/directly_recursive_polymorphic_compound_through_itself.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T]\n"
                          "    A[T] a\n"
                          "end\n"
                          "\n"
                          "structure B\n"
                          "    A[I32] a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/directly_recursive_polymorphic_compound_through_itself.owen");
    format_expectation(&test.expected_error, "%s:5:5: A[I32] is recursive." NEW_LINE
                                             "Polymorphic stack:" NEW_LINE
                                             "    semantics/compounds/directly_recursive_polymorphic_compound_through_itself.owen:9:5: A[I32]" NEW_LINE, test.source_paths[0]);
}

static void duplicate_formal_type_parameters(void)
{
    format_test_name("semantics/compounds/duplicate_formal_type_parameters");

    format_source_path(0, "semantics/compounds/duplicate_formal_type_parameters.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T, T]\n"
                          "    T x\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/duplicate_formal_type_parameters.owen");
    format_expectation(&test.expected_error, 
                       "semantics/compounds/duplicate_formal_type_parameters.owen:4:16: Duplicate formal type parameter T." NEW_LINE);
}

static void formal_type_parameter_with_the_same_name_as_a_primitive(void)
{
    format_test_name("semantics/compounds/formal_type_parameter_with_the_same_name_as_a_primitive");

    format_source_path(0, "semantics/compounds/formal_type_parameter_with_the_same_name_as_a_primitive.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[I32]\n"
                          "    I32 x\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/formal_type_parameter_with_the_same_name_as_a_primitive.owen");
    format_expectation(&test.expected_error, 
                       "semantics/compounds/formal_type_parameter_with_the_same_name_as_a_primitive.owen:4:13: Formal type parameter matches I32." NEW_LINE
                       "Declarations:" NEW_LINE
                       "    Primitive: I32" NEW_LINE
                       "    semantics/compounds/formal_type_parameter_with_the_same_name_as_a_primitive.owen:4:11: A[I32]" NEW_LINE);
}

static void formal_type_parameter_with_the_same_name_as_an_enumeration(void)
{
    format_test_name("semantics/compounds/formal_type_parameter_with_the_same_name_as_an_enumeration");

    format_source_path(0, "semantics/compounds/formal_type_parameter_with_the_same_name_as_an_enumeration.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "enumeration A : I32\n"
                          "end\n"
                          "\n"
                          "structure B[A]\n"
                          "    A a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/formal_type_parameter_with_the_same_name_as_an_enumeration.owen");
    format_expectation(&test.expected_error, 
                       "semantics/compounds/formal_type_parameter_with_the_same_name_as_an_enumeration.owen:7:13: Formal type parameter matches A." NEW_LINE
                       "Declarations:" NEW_LINE
                       "    semantics/compounds/formal_type_parameter_with_the_same_name_as_an_enumeration.owen:4:13: A" NEW_LINE
                       "    semantics/compounds/formal_type_parameter_with_the_same_name_as_an_enumeration.owen:7:11: B[A]" NEW_LINE);
}

static void formal_type_parameter_with_the_same_name_as_monomorphic_compound(void)
{
    format_test_name("semantics/compounds/formal_type_parameter_with_the_same_name_as_monomorphic_compound");

    format_source_path(0, "semantics/compounds/formal_type_parameter_with_the_same_name_as_monomorphic_compound.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A\n"
                          "    I32 x\n"
                          "end\n"
                          "\n"
                          "structure B[A]\n"
                          "    A a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/formal_type_parameter_with_the_same_name_as_monomorphic_compound.owen");
    format_expectation(&test.expected_error, 
                       "semantics/compounds/formal_type_parameter_with_the_same_name_as_monomorphic_compound.owen:8:13: Formal type parameter matches A." NEW_LINE
                       "Declarations:" NEW_LINE
                       "    semantics/compounds/formal_type_parameter_with_the_same_name_as_monomorphic_compound.owen:4:11: A" NEW_LINE
                       "    semantics/compounds/formal_type_parameter_with_the_same_name_as_monomorphic_compound.owen:8:11: B[A]" NEW_LINE);
}

static void indirectly_recursive_monomorphic_compound_through_fixed_sized_array(void)
{
    format_test_name("semantics/compounds/indirectly_recursive_monomorphic_compound_through_fixed_sized_array");

    format_source_path(0, "semantics/compounds/indirectly_recursive_monomorphic_compound_through_fixed_sized_array.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A\n"
                          "    [3]B b\n"
                          "end\n"
                          "\n"
                          "structure B\n"
                          "    C c\n"
                          "end\n"
                          "\n"
                          "structure C\n"
                          "    A a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/indirectly_recursive_monomorphic_compound_through_fixed_sized_array.owen");
    format_expectation(&test.expected_error, "%s:5:5: A is recursive." NEW_LINE, test.source_paths[0]);
}

static void indirectly_recursive_monomorphic_compound_through_monomorphic_compound(void)
{
    format_test_name("semantics/compounds/indirectly_recursive_monomorphic_compound_through_monomorphic_compound");

    format_source_path(0, "semantics/compounds/indirectly_recursive_monomorphic_compound_through_monomorphic_compound.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A\n"
                          "    B b\n"
                          "end\n"
                          "\n"
                          "structure B\n"
                          "    C c\n"
                          "end\n"
                          "\n"
                          "structure C\n"
                          "    A a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/indirectly_recursive_monomorphic_compound_through_monomorphic_compound.owen");
    format_expectation(&test.expected_error, "%s:5:5: A is recursive." NEW_LINE, test.source_paths[0]);
}

static void indirectly_recursive_polymorphic_compound_through_fixed_sized_array(void)
{
    format_test_name("semantics/compounds/indirectly_recursive_polymorphic_compound_through_fixed_sized_array");

    format_source_path(0, "semantics/compounds/indirectly_recursive_polymorphic_compound_through_fixed_sized_array.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T]\n"
                          "    [3]B[T] b\n"
                          "end\n"
                          "\n"
                          "structure B[T]\n"
                          "    A[T] a\n"
                          "end\n"
                          "\n"
                          "structure C\n"
                          "    A[I32] a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/indirectly_recursive_polymorphic_compound_through_fixed_sized_array.owen");
    format_expectation(&test.expected_error, 
                       "semantics/compounds/indirectly_recursive_polymorphic_compound_through_fixed_sized_array.owen:9:5: B[I32] is recursive." NEW_LINE
                       "Polymorphic stack:" NEW_LINE
                       "    semantics/compounds/indirectly_recursive_polymorphic_compound_through_fixed_sized_array.owen:13:5: A[I32]" NEW_LINE
                       "    semantics/compounds/indirectly_recursive_polymorphic_compound_through_fixed_sized_array.owen:5:8: B[I32]" NEW_LINE);
}

static void indirectly_recursive_monomorphic_compound_through_pointer(void)
{
    format_test_name("semantics/compounds/indirectly_recursive_monomorphic_compound_through_pointer");

    format_source_path(0, "semantics/compounds/indirectly_recursive_monomorphic_compound_through_pointer.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A\n"
                          "    #B b\n"
                          "end\n"
                          "\n"
                          "structure B\n"
                          "    C c\n"
                          "end\n"
                          "\n"
                          "structure C\n"
                          "    A a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/indirectly_recursive_monomorphic_compound_through_pointer.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/compounds/indirectly_recursive_monomorphic_compound_through_pointer.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        field" NEW_LINE
                       "            type: #B" NEW_LINE
                       "            name: b" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: B" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        field" NEW_LINE
                       "            type: C" NEW_LINE
                       "            name: c" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: C" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        field" NEW_LINE
                       "            type: A" NEW_LINE
                       "            name: a" NEW_LINE);
}

static void indirectly_recursive_polymorphic_compound_through_polymorphic_compound(void)
{
    format_test_name("semantics/compounds/indirectly_recursive_polymorphic_compound_through_polymorphic_compound");

    format_source_path(0, "semantics/compounds/indirectly_recursive_polymorphic_compound_through_polymorphic_compound.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T]\n"
                          "    B[T] b\n"
                          "end\n"
                          "\n"
                          "structure B[T]\n"
                          "    A[T] a\n"
                          "end\n"
                          "\n"
                          "structure C\n"
                          "    A[I32] a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/indirectly_recursive_polymorphic_compound_through_polymorphic_compound.owen");
    format_expectation(&test.expected_error, 
                       "semantics/compounds/indirectly_recursive_polymorphic_compound_through_polymorphic_compound.owen:9:5: B[I32] is recursive." NEW_LINE
                       "Polymorphic stack:" NEW_LINE
                       "    semantics/compounds/indirectly_recursive_polymorphic_compound_through_polymorphic_compound.owen:13:5: A[I32]" NEW_LINE
                       "    semantics/compounds/indirectly_recursive_polymorphic_compound_through_polymorphic_compound.owen:5:5: B[I32]" NEW_LINE);
}

static void matching_polymorphic_compounds(void)
{
    format_test_name("semantics/compounds/matching_polymorphic_compounds");

    format_source_path(0, "semantics/compounds/matching_polymorphic_compounds.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T1]\n"
                          "    T1 x\n"
                          "end\n"
                          "\n"
                          "structure A[T2]\n"
                          "    T2 x\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/matching_polymorphic_compounds.owen");
    format_expectation(&test.expected_error, 
                       "semantics/compounds/matching_polymorphic_compounds.owen:4:11: Matching declarations for A in scope." NEW_LINE
                       "Declarations:" NEW_LINE
                       "    semantics/compounds/matching_polymorphic_compounds.owen:4:11: A[T1]" NEW_LINE
                       "    semantics/compounds/matching_polymorphic_compounds.owen:8:11: A[T2]" NEW_LINE);
}

static void monomorphic_compound_defines_multiple_fields_with_the_same_name(void)
{
    format_test_name("semantics/compounds/monomorphic_compound_defines_multiple_fields_with_the_same_name");

    format_source_path(0, "semantics/compounds/monomorphic_compound_defines_multiple_fields_with_the_same_name.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A\n"
                          "    I32 a\n"
                          "    I32 b\n"
                          "    I32 c\n"
                          "    I32 d\n"
                          "    I32 a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/monomorphic_compound_defines_multiple_fields_with_the_same_name.owen");
    format_expectation(&test.expected_error, 
                       "semantics/compounds/monomorphic_compound_defines_multiple_fields_with_the_same_name.owen:9:9: Duplicate field name a." NEW_LINE);
}

static void monomorphic_compounds_with_the_same_name_in_different_namespaces(void)
{
    format_test_name("semantics/compounds/monomorphic_compounds_with_the_same_name_in_different_namespaces");

    format_source_path(0, "semantics/compounds/monomorphic_compounds_with_the_same_name_in_different_namespaces-1.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A\n"
                          "    I32 a\n"
                          "end");

    format_source_path(1, "semantics/compounds/monomorphic_compounds_with_the_same_name_in_different_namespaces-2.owen");
    format_source_file(1, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Def\n"
                          "\n"
                          "structure A\n"
                          "    I32 a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/monomorphic_compounds_with_the_same_name_in_different_namespaces-1.owen "
                     "semantics/compounds/monomorphic_compounds_with_the_same_name_in_different_namespaces-2.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/compounds/monomorphic_compounds_with_the_same_name_in_different_namespaces-1.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        field" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: a" NEW_LINE
                       "file" NEW_LINE
                       "    path: semantics/compounds/monomorphic_compounds_with_the_same_name_in_different_namespaces-2.owen" NEW_LINE
                       "    namespace: Def" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        field" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: a" NEW_LINE);
}

static void monomorphic_compounds_with_the_same_name_in_the_same_file(void)
{
    format_test_name("semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_file");

    format_source_path(0, "semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_file.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A\n"
                          "    I32 a\n"
                          "end\n"
                          "\n"
                          "structure A\n"
                          "    I32 a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_file.owen");
    format_expectation(&test.expected_error,
                       "semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_file.owen:4:11: Matching declarations for A in scope." NEW_LINE
                       "Declarations:" NEW_LINE
                       "    semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_file.owen:4:11: A" NEW_LINE
                       "    semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_file.owen:8:11: A" NEW_LINE);
}

static void monomorphic_compounds_with_the_same_name_in_the_same_namespaces_but_both_are_non_public(void)
{
    format_test_name("semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_namespaces_but_both_are_non_public");

    format_source_path(0, "semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_namespaces_but_both_are_non_public-1.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A\n"
                          "    I32 a\n"
                          "end");

    format_source_path(1, "semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_namespaces_but_both_are_non_public-2.owen");
    format_source_file(1, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A\n"
                          "    I32 a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_namespaces_but_both_are_non_public-1.owen "
                     "semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_namespaces_but_both_are_non_public-2.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_namespaces_but_both_are_non_public-1.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        field" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: a" NEW_LINE
                       "file" NEW_LINE
                       "    path: semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_namespaces_but_both_are_non_public-2.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        field" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: a" NEW_LINE);
}

static void monomorphic_compounds_with_the_same_name_in_the_same_namespaces_where_one_is_public(void)
{
    format_test_name("semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_namespaces_where_one_is_public");

    format_source_path(0, "semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_namespaces_where_one_is_public-1.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "public structure A\n"
                          "    I32 a\n"
                          "end");

    format_source_path(1, "semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_namespaces_where_one_is_public-2.owen");
    format_source_file(1, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A\n"
                          "    I32 a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_namespaces_where_one_is_public-1.owen "
                     "semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_namespaces_where_one_is_public-2.owen "
                     "-print-semantics");

    format_expectation(&test.expected_error, 
                       "semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_namespaces_where_one_is_public-2.owen:4:11: Matching declarations for A in scope." NEW_LINE
                       "Declarations:" NEW_LINE
                       "    semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_namespaces_where_one_is_public-2.owen:4:11: A" NEW_LINE
                       "    semantics/compounds/monomorphic_compounds_with_the_same_name_in_the_same_namespaces_where_one_is_public-1.owen:4:18: A" NEW_LINE);
}

static void nested_non_recursive_polymorphic_compounds(void)
{
    format_test_name("semantics/compounds/nested_non_recursive_polymorphic_compounds");

    format_source_path(0, "semantics/compounds/nested_non_recursive_polymorphic_compounds.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T]\n"
                          "    B[T] b\n"
                          "end\n"
                          "\n"
                          "structure B[T]\n"
                          "    T x\n"
                          "end\n"
                          "\n"
                          "function do_stuff(A[I32] a) : A[I32]\n"
                          "    return a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/nested_non_recursive_polymorphic_compounds.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/compounds/nested_non_recursive_polymorphic_compounds.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        formal_type_parameter: T" NEW_LINE
                       "        field" NEW_LINE
                       "            type_reference: B[T]" NEW_LINE
                       "            name: b" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        actual_type_parameter: I32" NEW_LINE
                       "        field" NEW_LINE
                       "            type: B[I32]" NEW_LINE
                       "            name: b" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: B" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        formal_type_parameter: T" NEW_LINE
                       "        field" NEW_LINE
                       "            type_reference: T" NEW_LINE
                       "            name: x" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: B" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        actual_type_parameter: I32" NEW_LINE
                       "        field" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: x" NEW_LINE
                       "    function" NEW_LINE
                       "        name: do_stuff" NEW_LINE
                       "        formal_parameter" NEW_LINE
                       "            type: A[I32]" NEW_LINE
                       "            name: a" NEW_LINE
                       "        return_type: A[I32]" NEW_LINE
                       "        return_statement" NEW_LINE
                       "            reference_expression" NEW_LINE
                       "                type: A[I32]" NEW_LINE
                       "                name: a" NEW_LINE);
}

static void non_recursive_monomorphic_compound_field(void)
{
    format_test_name("semantics/compounds/non_recursive_monomorphic_compound_field");

    format_source_path(0, "semantics/compounds/non_recursive_monomorphic_compound_field.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A\n"
                          "    B b\n"
                          "end\n"
                          "\n"
                          "structure B\n"
                          "    I32 x\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/non_recursive_monomorphic_compound_field.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/compounds/non_recursive_monomorphic_compound_field.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        field" NEW_LINE
                       "            type: B" NEW_LINE
                       "            name: b" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: B" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        field" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: x" NEW_LINE);
}

static void polymorphic_compound_defines_multiple_fields_with_the_same_name(void)
{
    format_test_name("semantics/compounds/polymorphic_compound_defines_multiple_fields_with_the_same_name");

    format_source_path(0, "semantics/compounds/polymorphic_compound_defines_multiple_fields_with_the_same_name.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T]\n"
                          "    T a\n"
                          "    T b\n"
                          "    T c\n"
                          "    T d\n"
                          "    T a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/polymorphic_compound_defines_multiple_fields_with_the_same_name.owen");
    format_expectation(&test.expected_error, 
                       "semantics/compounds/polymorphic_compound_defines_multiple_fields_with_the_same_name.owen:9:7: Duplicate field name a." NEW_LINE);
}

static void polymorphic_compound_with_formal_type_parameter_with_the_same_name(void)
{
    format_test_name("semantics/compounds/polymorphic_compound_with_formal_type_parameter_with_the_same_name");

    format_source_path(0, "semantics/compounds/polymorphic_compound_with_formal_type_parameter_with_the_same_name.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "// This is definitely one of those weird fringe cases\n"
                          "// but it is allowed since there is no primitive,\n"
                          "// enumeration or monomorphic compound named A\n"
                          "// in scope.\n"
                          "structure A[A]\n"
                          "    A x\n"
                          "end\n"
                          "\n"
                          "function do_stuff(A[I32] a) : A[I32]\n"
                          "    return a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/polymorphic_compound_with_formal_type_parameter_with_the_same_name.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/compounds/polymorphic_compound_with_formal_type_parameter_with_the_same_name.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        formal_type_parameter: A" NEW_LINE
                       "        field" NEW_LINE
                       "            type_reference: A" NEW_LINE
                       "            name: x" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        actual_type_parameter: I32" NEW_LINE
                       "        field" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: x" NEW_LINE
                       "    function" NEW_LINE
                       "        name: do_stuff" NEW_LINE
                       "        formal_parameter" NEW_LINE
                       "            type: A[I32]" NEW_LINE
                       "            name: a" NEW_LINE
                       "        return_type: A[I32]" NEW_LINE
                       "        return_statement" NEW_LINE
                       "            reference_expression" NEW_LINE
                       "                type: A[I32]" NEW_LINE
                       "                name: a" NEW_LINE);
}

static void polymorphic_compounds_with_the_same_name_but_different_amount_of_formal_type_parameters(void)
{
    format_test_name("semantics/compounds/polymorphic_compounds_with_the_same_name_but_different_amount_of_formal_type_parameters");

    format_source_path(0, "semantics/compounds/polymorphic_compounds_with_the_same_name_but_different_amount_of_formal_type_parameters.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A\n"
                          "    I32 x\n"
                          "    I32 y\n"
                          "end\n"
                          "\n"
                          "structure A[T1]\n"
                          "    T1 x\n"
                          "    T1 y\n"
                          "end\n"
                          "\n"
                          "structure A[T1, T2]\n"
                          "    T1 x\n"
                          "    T2 y\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/polymorphic_compounds_with_the_same_name_but_different_amount_of_formal_type_parameters.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/compounds/polymorphic_compounds_with_the_same_name_but_different_amount_of_formal_type_parameters.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        field" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: x" NEW_LINE
                       "        field" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: y" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        formal_type_parameter: T1" NEW_LINE
                       "        field" NEW_LINE
                       "            type_reference: T1" NEW_LINE
                       "            name: x" NEW_LINE
                       "        field" NEW_LINE
                       "            type_reference: T1" NEW_LINE
                       "            name: y" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        formal_type_parameter: T1" NEW_LINE
                       "        formal_type_parameter: T2" NEW_LINE
                       "        field" NEW_LINE
                       "            type_reference: T1" NEW_LINE
                       "            name: x" NEW_LINE
                       "        field" NEW_LINE
                       "            type_reference: T2" NEW_LINE
                       "            name: y" NEW_LINE);
}

static void public_compound_with_field_of_non_public_compound(void)
{
    format_test_name("semantics/compounds/public_compound_with_field_of_non_public_compound");

    format_source_path(0, "semantics/compounds/public_compound_with_field_of_non_public_compound.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "public structure A\n"
                          "    B b\n"
                          "end\n"
                          "\n"
                          "structure B\n"
                          "    I32 x\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/public_compound_with_field_of_non_public_compound.owen");
    format_expectation(&test.expected_error, 
                       "semantics/compounds/public_compound_with_field_of_non_public_compound.owen:5:5: A exposes B which is not public." NEW_LINE);
}

static void public_compound_with_field_of_non_public_enumeration(void)
{
    format_test_name("semantics/compounds/public_compound_with_field_of_non_public_enumeration");

    format_source_path(0, "semantics/compounds/public_compound_with_field_of_non_public_enumeration.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "public structure A\n"
                          "    B b\n"
                          "end\n"
                          "\n"
                          "enumeration B : I32\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/public_compound_with_field_of_non_public_enumeration.owen");
    format_expectation(&test.expected_error, 
                       "semantics/compounds/public_compound_with_field_of_non_public_enumeration.owen:5:5: A exposes B which is not public." NEW_LINE);
}

static void public_compound_with_field_of_public_compound(void)
{
    format_test_name("semantics/compounds/public_compound_with_field_of_public_compound");

    format_source_path(0, "semantics/compounds/public_compound_with_field_of_public_compound.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "public structure A\n"
                          "    B b\n"
                          "end\n"
                          "\n"
                          "public structure B\n"
                          "    I32 x\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/public_compound_with_field_of_public_compound.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/compounds/public_compound_with_field_of_public_compound.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: true" NEW_LINE
                       "        field" NEW_LINE
                       "            type: B" NEW_LINE
                       "            name: b" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: B" NEW_LINE
                       "        is_public: true" NEW_LINE
                       "        field" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: x" NEW_LINE);
}

static void public_compound_with_field_of_public_enumeration(void)
{
    format_test_name("semantics/compounds/public_compound_with_field_of_public_enumeration");

    format_source_path(0, "semantics/compounds/public_compound_with_field_of_public_enumeration.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "public structure A\n"
                          "    B b\n"
                          "end\n"
                          "\n"
                          "public enumeration B : I32\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/public_compound_with_field_of_public_enumeration.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/compounds/public_compound_with_field_of_public_enumeration.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: true" NEW_LINE
                       "        field" NEW_LINE
                       "            type: B" NEW_LINE
                       "            name: b" NEW_LINE
                       "    enumeration" NEW_LINE
                       "        name: B" NEW_LINE
                       "        underlying_type: I32" NEW_LINE
                       "        is_public: true" NEW_LINE);
}

static void missing_actual_type_parameter_in_polymorphic_field_type(void)
{
    format_test_name("semantics/compounds/missing_actual_type_parameter_in_polymorphic_field_type");

    format_source_path(0, "semantics/compounds/missing_actual_type_parameter_in_polymorphic_field_type.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T]\n"
                          "    A a\n"
                          "end\n"
                          "\n"
                          "structure B\n"
                          "    A[I32] a\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/missing_actual_type_parameter_in_polymorphic_field_type.owen");
    format_expectation(&test.expected_error,
                       "semantics/compounds/missing_actual_type_parameter_in_polymorphic_field_type.owen:5:5: Undefined type referenced." NEW_LINE
                       "Polymorphic stack:" NEW_LINE
                       "    semantics/compounds/missing_actual_type_parameter_in_polymorphic_field_type.owen:9:5: A[I32]" NEW_LINE);
}

static void monomorphic_field_type_is_undefined_in_monomorphic_compound(void)
{
    format_test_name("semantics/compounds/monomorphic_field_type_is_undefined_in_monomorphic_compound");

    format_source_path(0, "semantics/compounds/monomorphic_field_type_is_undefined_in_monomorphic_compound.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A\n"
                          "    B b\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/monomorphic_field_type_is_undefined_in_monomorphic_compound.owen");
    format_expectation(&test.expected_error, 
                       "semantics/compounds/monomorphic_field_type_is_undefined_in_monomorphic_compound.owen:5:5: Undefined type referenced." NEW_LINE);
}

static void polymorphic_type_using_formal_type_parameter(void)
{
    format_test_name("semantics/compounds/polymorphic_type_using_formal_type_parameter");

    format_source_path(0, "semantics/compounds/polymorphic_type_using_formal_type_parameter.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T]\n"
                          "    B[T] a\n"
                          "end\n"
                          "\n"
                          "structure B[T]\n"
                          "    T a\n"
                          "end\n"
                          "\n"
                          "structure C\n"
                          "    A[I32] x\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/polymorphic_type_using_formal_type_parameter.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/compounds/polymorphic_type_using_formal_type_parameter.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        formal_type_parameter: T" NEW_LINE
                       "        field" NEW_LINE
                       "            type_reference: B[T]" NEW_LINE
                       "            name: a" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        actual_type_parameter: I32" NEW_LINE
                       "        field" NEW_LINE
                       "            type: B[I32]" NEW_LINE
                       "            name: a" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: B" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        formal_type_parameter: T" NEW_LINE
                       "        field" NEW_LINE
                       "            type_reference: T" NEW_LINE
                       "            name: a" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: B" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        actual_type_parameter: I32" NEW_LINE
                       "        field" NEW_LINE
                       "            type: I32" NEW_LINE
                       "            name: a" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: C" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        field" NEW_LINE
                       "            type: A[I32]" NEW_LINE
                       "            name: x" NEW_LINE);
}

static void pointer_to_formal_type_parameter(void)
{
    format_test_name("semantics/compounds/pointer_to_formal_type_parameter");

    format_source_path(0, "semantics/compounds/pointer_to_formal_type_parameter.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T]\n"
                          "    #?T a\n"
                          "end\n"
                          "\n"
                          "structure B\n"
                          "    A[I32] x\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/pointer_to_formal_type_parameter.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/compounds/pointer_to_formal_type_parameter.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        formal_type_parameter: T" NEW_LINE
                       "        field" NEW_LINE
                       "            type_reference: #?T" NEW_LINE
                       "            name: a" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        actual_type_parameter: I32" NEW_LINE
                       "        field" NEW_LINE
                       "            type: #?I32" NEW_LINE
                       "            name: a" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: B" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        field" NEW_LINE
                       "            type: A[I32]" NEW_LINE
                       "            name: x" NEW_LINE);
}

static void dynamic_array_of_formal_type_parameter(void)
{
    format_test_name("semantics/compounds/dynamic_array_of_formal_type_parameter");

    format_source_path(0, "semantics/compounds/dynamic_array_of_formal_type_parameter.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T]\n"
                          "    []T a\n"
                          "end\n"
                          "\n"
                          "structure B\n"
                          "    A[I32] x\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/dynamic_array_of_formal_type_parameter.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/compounds/dynamic_array_of_formal_type_parameter.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        formal_type_parameter: T" NEW_LINE
                       "        field" NEW_LINE
                       "            type_reference: []T" NEW_LINE
                       "            name: a" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        actual_type_parameter: I32" NEW_LINE
                       "        field" NEW_LINE
                       "            type: []I32" NEW_LINE
                       "            name: a" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: B" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        field" NEW_LINE
                       "            type: A[I32]" NEW_LINE
                       "            name: x" NEW_LINE);
}

static void fixed_array_of_formal_type_parameter(void)
{
    format_test_name("semantics/compounds/fixed_array_of_formal_type_parameter");

    format_source_path(0, "semantics/compounds/fixed_array_of_formal_type_parameter.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T]\n"
                          "    [2]T a\n"
                          "end\n"
                          "\n"
                          "structure B\n"
                          "    A[I32] x\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/fixed_array_of_formal_type_parameter.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/compounds/fixed_array_of_formal_type_parameter.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        formal_type_parameter: T" NEW_LINE
                       "        field" NEW_LINE
                       "            type_reference: [2]T" NEW_LINE
                       "            name: a" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: A" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        actual_type_parameter: I32" NEW_LINE
                       "        field" NEW_LINE
                       "            type: [2]I32" NEW_LINE
                       "            name: a" NEW_LINE
                       "    structure" NEW_LINE
                       "        name: B" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        field" NEW_LINE
                       "            type: A[I32]" NEW_LINE
                       "            name: x" NEW_LINE);
}

static void nested_formal_type_parameter(void)
{
    format_test_name("semantics/compounds/nested_formal_type_parameter");

    format_source_path(0, "semantics/compounds/nested_formal_type_parameter.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "structure A[T]\n"
                          "    T[I32] b\n"
                          "end");

    SET_COMMAND_LINE("semantics/compounds/nested_formal_type_parameter.owen");
    format_expectation(&test.expected_error, 
                       "semantics/compounds/nested_formal_type_parameter.owen:5:5: Type parameters can't be nested." NEW_LINE);
}

bool semantics_compounds(void)
{
    static uint8_t state;
    switch (state++)
    {
        case 0:
            comparing_polymorphic_compound_with_non_matching_actual_type_parameters();
            break;

        case 1:
            directly_recursive_monomorphic_compound_through_fixed_sized_array();
            break;

        case 2:
            directly_recursive_monomorphic_compound_through_itself();
            break;

        case 3:
            directly_recursive_polymorphic_compound_through_fixed_sized_array();
            break;

        case 4:
            directly_recursive_polymorphic_compound_through_itself();
            break;

        case 5:
            duplicate_formal_type_parameters();
            break;

        case 6:
            formal_type_parameter_with_the_same_name_as_a_primitive();
            break;

        case 7:
            formal_type_parameter_with_the_same_name_as_an_enumeration();
            break;

        case 8:
            formal_type_parameter_with_the_same_name_as_monomorphic_compound();
            break;

        case 9:
            indirectly_recursive_monomorphic_compound_through_fixed_sized_array();
            break;

        case 10:
            indirectly_recursive_monomorphic_compound_through_monomorphic_compound();
            break;

        case 11:
            indirectly_recursive_polymorphic_compound_through_fixed_sized_array();
            break;

        case 12:
            indirectly_recursive_monomorphic_compound_through_pointer();
            break;

        case 13:
            indirectly_recursive_polymorphic_compound_through_polymorphic_compound();
            break;

        case 14:
            matching_polymorphic_compounds();
            break;

        case 15:
            monomorphic_compound_defines_multiple_fields_with_the_same_name();
            break;

        case 16:
            monomorphic_compounds_with_the_same_name_in_different_namespaces();
            break;

        case 17:
            monomorphic_compounds_with_the_same_name_in_the_same_file();
            break;

        case 18:
            monomorphic_compounds_with_the_same_name_in_the_same_namespaces_but_both_are_non_public();
            break;

        case 19:
            monomorphic_compounds_with_the_same_name_in_the_same_namespaces_where_one_is_public();
            break;

        case 20:
            nested_non_recursive_polymorphic_compounds();
            break;

        case 21:
            non_recursive_monomorphic_compound_field();
            break;

        case 22:
            polymorphic_compound_defines_multiple_fields_with_the_same_name();
            break;

        case 23:
            polymorphic_compound_with_formal_type_parameter_with_the_same_name();
            break;

        case 24:
            polymorphic_compounds_with_the_same_name_but_different_amount_of_formal_type_parameters();
            break;

        case 25:
            public_compound_with_field_of_non_public_compound();
            break;

        case 26:
            public_compound_with_field_of_non_public_enumeration();
            break;

        case 27:
            public_compound_with_field_of_public_compound();
            break;

        case 28:
            public_compound_with_field_of_public_enumeration();
            break;

        case 29:
            missing_actual_type_parameter_in_polymorphic_field_type();
            break;

        case 30:
            monomorphic_field_type_is_undefined_in_monomorphic_compound();
            break;

        case 31:
            polymorphic_type_using_formal_type_parameter();
            break;

        case 32:
            pointer_to_formal_type_parameter();
            break;

        case 33:
            dynamic_array_of_formal_type_parameter();
            break;

        case 34:
            fixed_array_of_formal_type_parameter();
            break;

        case 35:
            nested_formal_type_parameter();
            break;

        default:
            return false;
    }

    return true;
}
