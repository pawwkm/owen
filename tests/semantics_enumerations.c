#include "runner.h"

static void enumerations_with_the_same_name_in_different_namespaces(void)
{
    format_test_name("semantics/enumerations/enumerations_with_the_same_name_in_different_namespaces");

    format_source_path(0, "semantics/enumerations/enumerations_with_the_same_name_in_different_namespaces-1.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "enumeration A : I32\n"
                          "end");

    format_source_path(1, "semantics/enumerations/enumerations_with_the_same_name_in_different_namespaces-2.owen");
    format_source_file(1, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Def\n"
                          "\n"
                          "enumeration A : I32\n"
                          "end");

    SET_COMMAND_LINE("semantics/enumerations/enumerations_with_the_same_name_in_different_namespaces-1.owen "
                     "semantics/enumerations/enumerations_with_the_same_name_in_different_namespaces-2.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/enumerations/enumerations_with_the_same_name_in_different_namespaces-1.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    enumeration" NEW_LINE
                       "        name: A" NEW_LINE
                       "        underlying_type: I32" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "file" NEW_LINE
                       "    path: semantics/enumerations/enumerations_with_the_same_name_in_different_namespaces-2.owen" NEW_LINE
                       "    namespace: Def" NEW_LINE
                       "    enumeration" NEW_LINE
                       "        name: A" NEW_LINE
                       "        underlying_type: I32" NEW_LINE
                       "        is_public: false" NEW_LINE);
}

static void enumerations_with_the_same_name_in_the_same_file(void)
{
    format_test_name("semantics/enumerations/enumerations_with_the_same_name_in_the_same_file");

    format_source_path(0, "semantics/enumerations/enumerations_with_the_same_name_in_the_same_file.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "enumeration A : I32\n"
                          "end\n"
                          "\n"
                          "enumeration A : I32\n"
                          "end");

    SET_COMMAND_LINE("semantics/enumerations/enumerations_with_the_same_name_in_the_same_file.owen");
    format_expectation(&test.expected_error, 
                       "semantics/enumerations/enumerations_with_the_same_name_in_the_same_file.owen:4:13: Matching declarations for A in scope." NEW_LINE
                       "Declarations:" NEW_LINE
                       "    semantics/enumerations/enumerations_with_the_same_name_in_the_same_file.owen:4:13: A" NEW_LINE
                       "    semantics/enumerations/enumerations_with_the_same_name_in_the_same_file.owen:7:13: A" NEW_LINE);
}

static void enumerations_with_the_same_name_in_the_same_namespaces(void)
{
    format_test_name("semantics/enumerations/enumerations_with_the_same_name_in_the_same_namespaces");

    format_source_path(0, "semantics/enumerations/enumerations_with_the_same_name_in_the_same_namespaces-1.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "enumeration A : I32\n"
                          "end");

    format_source_path(1, "semantics/enumerations/enumerations_with_the_same_name_in_the_same_namespaces-2.owen");
    format_source_file(1, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Def\n"
                          "\n"
                          "enumeration A : I32\n"
                          "end");

    SET_COMMAND_LINE("semantics/enumerations/enumerations_with_the_same_name_in_the_same_namespaces-1.owen "
                     "semantics/enumerations/enumerations_with_the_same_name_in_the_same_namespaces-2.owen "
                     "-print-semantics");

    format_expectation(&test.expected_semantics, 
                       "file" NEW_LINE
                       "    path: semantics/enumerations/enumerations_with_the_same_name_in_the_same_namespaces-1.owen" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    enumeration" NEW_LINE
                       "        name: A" NEW_LINE
                       "        underlying_type: I32" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "file" NEW_LINE
                       "    path: semantics/enumerations/enumerations_with_the_same_name_in_the_same_namespaces-2.owen" NEW_LINE
                       "    namespace: Def" NEW_LINE
                       "    enumeration" NEW_LINE
                       "        name: A" NEW_LINE
                       "        underlying_type: I32" NEW_LINE
                       "        is_public: false" NEW_LINE);
}

static void enumerations_with_the_same_name_in_the_same_namespaces_where_one_is_public(void)
{
    format_test_name("semantics/enumerations/enumerations_with_the_same_name_in_the_same_namespaces_where_one_is_public");

    format_source_path(0, "semantics/enumerations/enumerations_with_the_same_name_in_the_same_namespaces_where_one_is_public-1.owen");
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "public enumeration A : I32\n"
                          "end");

    format_source_path(1, "semantics/enumerations/enumerations_with_the_same_name_in_the_same_namespaces_where_one_is_public-2.owen");
    format_source_file(1, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "enumeration A : I32\n"
                          "end");

    SET_COMMAND_LINE("semantics/enumerations/enumerations_with_the_same_name_in_the_same_namespaces_where_one_is_public-1.owen "
                     "semantics/enumerations/enumerations_with_the_same_name_in_the_same_namespaces_where_one_is_public-2.owen");

    format_expectation(&test.expected_error, 
                       "semantics/enumerations/enumerations_with_the_same_name_in_the_same_namespaces_where_one_is_public-2.owen:4:13: Matching declarations for A in scope." NEW_LINE
                       "Declarations:" NEW_LINE
                       "    semantics/enumerations/enumerations_with_the_same_name_in_the_same_namespaces_where_one_is_public-2.owen:4:13: A" NEW_LINE
                       "    semantics/enumerations/enumerations_with_the_same_name_in_the_same_namespaces_where_one_is_public-1.owen:4:20: A" NEW_LINE);
}

static bool x_typed_constant_overflowing_the_underlying_type(void)
{
    static uint8_t index = FIRST_INTEGER_TYPE_INDEX;
    if (index > LAST_INTEGER_TYPE_INDEX)
        return false;

    format_test_name("semantics/enumerations/%s_constant_overflowing_the_underlying_type", types[index].file_friendly_name);

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "enumeration A : %s\n"
                          "    a = %s\n"
                          "end",
                          types[index].name,
                          types[index].overflow_value);

    format_command_line_options("%s", test.source_paths[0]);
    format_expectation(&test.expected_error, 
                       "%s:5:9: %s overflows %s." NEW_LINE,
                       test.source_paths[0], types[index].overflow_value, types[index].name);

    index++;
    return true;
}

static bool x_typed_constant_underflowing_the_underlying_type(void)
{
    static uint8_t index = FIRST_SIGNED_NUMBER_TYPE_INDEX;
    if (index > LAST_SIGNED_NUMBER_TYPE_INDEX)
        return false;

    format_test_name("semantics/enumerations/%s_constant_underflowing_the_underlying_type", types[index].file_friendly_name);

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "enumeration A : %s\n"
                          "    a = %s\n"
                          "end",
                          types[index].name,
                          types[index].underflow_value);

    format_command_line_options("%s", test.source_paths[0]);
    format_expectation(&test.expected_error, 
                       "%s:5:9: %s underflows %s." NEW_LINE,
                       test.source_paths[0], types[index].underflow_value, types[index].name);

    index++;
    return true;
}

static bool x_typed_explicitly_positive_valued_constant_followed_by_implicitly_valued_constant(void)
{
    static uint8_t index = FIRST_INTEGER_TYPE_INDEX;
    if (index > LAST_INTEGER_TYPE_INDEX)
        return false;

    format_test_name("semantics/enumerations/%s_typed_explicitly_positive_valued_constant_followed_by_implicitly_valued_constant", types[index].file_friendly_name);

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "enumeration A : %s\n"
                          "    a = 4\n"
                          "    b\n"
                          "end",
                          types[index].name);

    format_command_line_options("%s -print-semantics", test.source_paths[0]);
    format_expectation(&test.expected_semantics,
                       "file" NEW_LINE
                       "    path: %s" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    enumeration" NEW_LINE
                       "        name: A" NEW_LINE
                       "        underlying_type: %s" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        constant" NEW_LINE
                       "            name: a" NEW_LINE
                       "            value: 4" NEW_LINE
                       "        constant" NEW_LINE
                       "            name: b" NEW_LINE
                       "            value: 5" NEW_LINE,
                       test.source_paths[0],
                       types[index].name);

    index++;
    return true;
}

static bool x_typed_explicitly_negative_valued_constant_followed_by_implicitly_valued_constant(void)
{
    static uint8_t index = FIRST_SIGNED_NUMBER_TYPE_INDEX;
    if (index > LAST_SIGNED_NUMBER_TYPE_INDEX)
        return false;

    format_test_name("semantics/enumerations/%s_typed_explicitly_negative_valued_constant_followed_by_implicitly_valued_constant", types[index].file_friendly_name);

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "enumeration A : %s\n"
                          "    a = -4\n"
                          "    b\n"
                          "end",
                          types[index].name);

    format_command_line_options("%s -print-semantics", test.source_paths[0]);
    format_expectation(&test.expected_semantics,
                       "file" NEW_LINE
                       "    path: %s" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    enumeration" NEW_LINE
                       "        name: A" NEW_LINE
                       "        underlying_type: %s" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        constant" NEW_LINE
                       "            name: a" NEW_LINE
                       "            value: -4" NEW_LINE
                       "        constant" NEW_LINE
                       "            name: b" NEW_LINE
                       "            value: -3" NEW_LINE,
                       test.source_paths[0],
                       types[index].name);

    index++;
    return true;
}

static bool x_typed_implicitly_valued_constant_between_explicitly_valued_constants(void)
{
    static uint8_t index = FIRST_INTEGER_TYPE_INDEX;
    if (index > LAST_INTEGER_TYPE_INDEX)
        return false;

    format_test_name("semantics/enumerations/%s_typed_implicitly_valued_constant_between_explicitly_valued_constants", types[index].file_friendly_name);

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "enumeration A : %s\n"
                          "    a = 2\n"
                          "    b\n"
                          "    c = 6\n"
                          "end",
                          types[index].name);

    format_command_line_options("%s -print-semantics", test.source_paths[0]);
    format_expectation(&test.expected_semantics,
                       "file" NEW_LINE
                       "    path: %s" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    enumeration" NEW_LINE
                       "        name: A" NEW_LINE
                       "        underlying_type: %s" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        constant" NEW_LINE
                       "            name: a" NEW_LINE
                       "            value: 2" NEW_LINE
                       "        constant" NEW_LINE
                       "            name: b" NEW_LINE
                       "            value: 3" NEW_LINE
                       "        constant" NEW_LINE
                       "            name: c" NEW_LINE
                       "            value: 6" NEW_LINE,
                       test.source_paths[0],
                       types[index].name);

    index++;
    return true;
}

static bool x_typed_implicitly_valued_constants_only(void)
{
    static uint8_t index = FIRST_INTEGER_TYPE_INDEX;
    if (index > LAST_INTEGER_TYPE_INDEX)
        return false;

    format_test_name("semantics/enumerations/%s_typed_implicitly_valued_constants_only", types[index].file_friendly_name);

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "enumeration A : %s\n"
                          "    a\n"
                          "    b\n"
                          "    c\n"
                          "end",
                          types[index].name);

    format_command_line_options("%s -print-semantics", test.source_paths[0]);
    format_expectation(&test.expected_semantics,
                       "file" NEW_LINE
                       "    path: %s" NEW_LINE
                       "    namespace: Abc" NEW_LINE
                       "    enumeration" NEW_LINE
                       "        name: A" NEW_LINE
                       "        underlying_type: %s" NEW_LINE
                       "        is_public: false" NEW_LINE
                       "        constant" NEW_LINE
                       "            name: a" NEW_LINE
                       "            value: 0" NEW_LINE
                       "        constant" NEW_LINE
                       "            name: b" NEW_LINE
                       "            value: 1" NEW_LINE
                       "        constant" NEW_LINE
                       "            name: c" NEW_LINE
                       "            value: 2" NEW_LINE,
                       test.source_paths[0],
                       types[index].name);

    index++;
    return true;
}

static bool x_typed_implicitly_valued_constants_overflow_underlying_type(void)
{
    static uint8_t index = FIRST_INTEGER_TYPE_INDEX;
    if (index > LAST_INTEGER_TYPE_INDEX)
        return false;

    format_test_name("semantics/enumerations/%s_typed_implicitly_valued_constants_overflow_underlying_type", types[index].file_friendly_name);

    format_source_path(0, "%s.owen", test.name);
    format_source_file(0, "// Generated by " __FILE__ " " __FUNCSIG__ "\n"
                          "namespace Abc\n"
                          "\n"
                          "enumeration A : %s\n"
                          "    a = %s\n"
                          "    b\n"
                          "end",
                          types[index].name,
                          types[index].max_value);

    format_command_line_options("%s", test.source_paths[0]);
    format_expectation(&test.expected_error,
                       "%s:6:5: b overflows %s."  NEW_LINE,
                       test.source_paths[0], types[index].name);

    index++;
    return true;
}

bool semantics_enumerations(void)
{
    static uint8_t state;
    switch (state)
    {
        case 0:
            enumerations_with_the_same_name_in_different_namespaces();
            state++;
            break;

        case 1:
            enumerations_with_the_same_name_in_the_same_file();
            state++;
            break;

        case 2:
            enumerations_with_the_same_name_in_the_same_namespaces();
            state++;
            break;

        case 3:
            enumerations_with_the_same_name_in_the_same_namespaces_where_one_is_public();
            state++;
            break;

        case 4:
            if (x_typed_constant_overflowing_the_underlying_type())
                break;

            state++;
            
        case 5:
            if (x_typed_constant_underflowing_the_underlying_type())
                break;

            state++;

        case 6:
            if (x_typed_explicitly_positive_valued_constant_followed_by_implicitly_valued_constant())
                break;

            state++;

        case 7:
            if (x_typed_explicitly_negative_valued_constant_followed_by_implicitly_valued_constant())
                break;

            state++;

        case 8:
            if (x_typed_implicitly_valued_constant_between_explicitly_valued_constants())
                break;

            state++;

        case 9:
            if (x_typed_implicitly_valued_constants_only())
                break;

            state++;

        case 10:
            if (x_typed_implicitly_valued_constants_overflow_underlying_type())
                break;

            state++;

        default:
            return false;
    }

    return true;
}
